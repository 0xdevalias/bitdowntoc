package ch.derlin.bitdowntoc

data class GeneratorOptions(
    val indentCharacters: List<Char> = listOf('-', '*', '+'),
    val generateAnchors: Boolean = true,
    val trimTocIndent: Boolean = true,
    val oneShot: Boolean = false
)

object BitGenerator {

    data class TocEntry(val indent: Int, val title: String, val link: String)

    // TODO: tests
    private class Toc {
        private val titles: MutableMap<String, Int> = mutableMapOf()
        private val entries: MutableList<TocEntry> = mutableListOf()

        fun addTocEntry(indent: Int, title: String): TocEntry {
            var link = title.escapeTitle()
            // add numbers at the end of the link if it is a duplicate
            val duplicates = (titles.get(title) ?: 0)
            if (duplicates > 0) {
                link += "-${duplicates}"
            }
            titles[title] = duplicates + 1
            // create the entry
            val entry = TocEntry(indent - 1, title, link)
            entries += entry
            return entry
        }

        fun generateToc(indentCharacters: List<Char>, trimTocIndent: Boolean): String {
            val minIndent = if (trimTocIndent) entries.minOf { it.indent } else 0
            return entries.joinToString(System.lineSeparator()) { (indent, text, link) ->
                (indent - minIndent).let {
                    " ".repeat(it * 2) + "${indentCharacters[it % indentCharacters.size]} [$text]($link)"
                }
            }
        }

        private fun String.escapeTitle() =
            this.replace("[^\\w]".toRegex(), "-").toLowerCase()
    }

    private const val tocMarker = "[TOC]"
    private const val tocStart = "<!-- TOC start -->"
    private const val tocEnd = "<!-- TOC end -->"

    private const val anchorPrefix = "<!-- TOC -->"
    private const val sectionMarkerFmt = """<a name="%s"></a>"""

    private val headerRegex = "(#+) +([^ ]+.*)".toRegex()
    private val codeRegex = "^```\\w* *$".toRegex()
    private val sectionMarkerRegex = "$anchorPrefix <a name=\".*\"></a>.*".toRegex()

    fun generate(text: String, options: GeneratorOptions = GeneratorOptions()): String {

        require(text.hasToc()) {
            "This library requires a [TOC] placeholder (or a TOC previously generated by this library"
        }

        val toc = Toc()
        val lines = text.lines().toMutableList()
        val iter = lines.listIterator()
        val anchorFmt = (if (options.oneShot) "" else anchorPrefix) + sectionMarkerFmt

        // consume text up to the toc marker
        while (iter.hasNext()) {
            when (iter.next().trim()) {
                tocStart -> {
                    iter.consumeToc()
                    break
                }
                tocMarker -> break
            }
        }

        while (iter.hasNext()) {
            val line = iter.next()
            when {
                codeRegex.matches(line) -> iter.consumeCode()
                sectionMarkerRegex.matches(line) -> iter.remove()
                else -> line.parseHeader(toc)?.let {
                    if (options.generateAnchors) {
                        iter.add(anchorFmt.format(it.link))
                    }
                }
            }
        }

        val tocString = toc.generateToc(options.indentCharacters, options.trimTocIndent).let {
            if (!options.oneShot) {
                """
                |$tocStart
                |${it}
                |$tocEnd
                """.trimMargin()
            } else {
                it
            }
        }

        return lines.joinToString(System.lineSeparator()).replace(tocMarker, tocString)

    }


    private fun String.parseHeader(toc: Toc) =
        headerRegex.matchEntire(this)?.let {
            val indent = it.groupValues[1].length
            val title = it.groupValues[2]
            toc.addTocEntry(indent, title)
        }

    private fun String.hasToc(): Boolean =
        this.contains(tocMarker) || this.contains(tocStart)

    private fun MutableListIterator<String>.consumeToc() {
        do {
            this.remove()
        } while (this.hasNext() && this.next() != tocEnd)
        this.set("[TOC]")
    }

    private fun Iterator<String>.consumeCode() {
        while (this.hasNext() && !codeRegex.matches(this.next()));
    }

}
