package ch.derlin.bitdowntoc

import java.io.File

private typealias BitTocEntry = Triple<Int, String, String>

object BitGenerator {

    // TODO: name clashes, tests, klickt

    data class State(
        val lines: MutableList<String> = mutableListOf(),
        val toc: MutableList<BitTocEntry> = mutableListOf()
    )

    private const val tocMarker = "[TOC]"
    private const val tocStart = "<!-- TOC start -->"
    private const val tocEnd = "<!-- TOC end -->"

    private val headerRegex = "(#+) +([^ ]+.*)".toRegex()
    private val codeRegex = "^```\\w* *$".toRegex()

    private val linkRegex = "<!-- TOC --> <a name=\".*\"></a>.*".toRegex()
    private const val linkFmt = """<!-- TOC --> <a name="%s"></a>"""
    private val indentCharacters = listOf("-", "*", "+")

    fun generate(filePath: String): String {
        val text = File(filePath).readText()

        require(text.hasToc()) {
            "This library requires a [TOC] placeholder (or a TOC previously generated by this library"
        }

        val state = State()
        val iter = text.lineSequence().iterator()

        // consume text up to the toc marker
        while (iter.hasNext() && state.lines.lastOrNull() != tocMarker) {
            val line = iter.next()
            if (line.trim() == tocStart) {
                // a previously generated TOC: remove it and add the toc marker instead
                state.lines += tocMarker
                iter.consumeToc(state)
                break
            } else {
                state.lines += line
            }
        }

        while (iter.hasNext()) {
            val line = iter.next()
            if (codeRegex.matches(line)) {
                state.lines += line
                iter.consumeCode(state)
            } else {
                if (linkRegex.matches(line)) {
                    // do nothing
                } else {
                    state.lines += line
                    line.parseHeader()?.let {
                        state.toc += it
                        state.lines += listOf(it.genSectionLink() + "")
                    }
                }
            }
        }

        val toc = """
            |$tocStart
            |${state.toc.generateToc()}
            |$tocEnd
        """.trimMargin() + System.lineSeparator()

        return state.lines.joinToString(System.lineSeparator()).replace(tocMarker, toc)
    }

    private fun List<BitTocEntry>.generateToc(): String {
        val minIndent = this.minOf { it.first }
        return this.joinToString(System.lineSeparator()) { (indent, text, link) ->
            (indent - minIndent).let {
                " ".repeat(it * 2) + "${indentCharacters[it % indentCharacters.size]} [$text]($link)"
            }
        }
    }


    private fun String.parseHeader() =
        headerRegex.matchEntire(this)?.let {
            val indent = it.groupValues[1].length
            val title = it.groupValues[2]
            Triple(indent - 1, title, title.escapeTitle())
        }

    private fun String.hasToc(): Boolean =
        this.contains(tocMarker) || this.contains(tocStart)

    private fun String.escapeTitle() =
        this.replace("[^\\w]+".toRegex(), "-").toLowerCase()


    private fun BitTocEntry.genSectionLink() = linkFmt.format(this.third)

    private fun Iterator<String>.consumeToc(state: State) {
        while (this.hasNext() && this.next() != tocEnd);
    }

    private fun Iterator<String>.consumeCode(state: State) {
        while (this.hasNext()) {
            state.lines += this.next()
            if (codeRegex.matches(state.lines.last())) break
        }
    }

}
