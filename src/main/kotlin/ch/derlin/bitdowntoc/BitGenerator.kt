package ch.derlin.bitdowntoc

data class GeneratorOptions(
    val indentCharacters: List<Char> = listOf('-', '*', '+'),
    val generateAnchors: Boolean = true,
    val trimTocIndent: Boolean = true,
    val concatSpaces: Boolean = true,
    val oneShot: Boolean = false
)

object BitGenerator {

    // TODO: tests

    private const val tocMarker = "[TOC]"
    private const val tocStart = "<!-- TOC start -->"
    private const val tocEnd = "<!-- TOC end -->"

    private const val anchorPrefix = "<!-- TOC -->"
    private const val sectionMarkerFmt = """<a name="%s"></a>"""

    private val headerRegex = "(#+) +([^ ]+.*)".toRegex()
    private val codeRegex = "^```\\w* *$".toRegex()
    private val sectionMarkerRegex = "$anchorPrefix <a name=\".*\"></a>.*".toRegex()

    fun generate(text: String, options: GeneratorOptions = GeneratorOptions()): String {

        require(text.hasToc()) {
            "This library requires a [TOC] placeholder (or a TOC previously generated by this library"
        }

        val toc = Toc(concatSpaces = options.concatSpaces)
        val lines = text.lines().toMutableList()
        val iter = lines.listIterator()
        val anchorFmt = (if (options.oneShot) "" else anchorPrefix) + sectionMarkerFmt

        // consume text up to the toc marker
        while (iter.hasNext()) {
            when (iter.next().trim()) {
                tocStart -> {
                    iter.consumeToc()
                    break
                }
                tocMarker -> break
            }
        }

        while (iter.hasNext()) {
            val line = iter.next()
            when {
                codeRegex.matches(line) -> iter.consumeCode()
                sectionMarkerRegex.matches(line) -> iter.remove()
                else -> line.parseHeader(toc)?.let {
                    if (options.generateAnchors) {
                        iter.add(anchorFmt.format(it.link))
                    }
                }
            }
        }

        val tocString = toc.generateToc(options.indentCharacters, options.trimTocIndent).let {
            if (!options.oneShot) {
                """
                |$tocStart
                |${it}
                |$tocEnd
                """.trimMargin()
            } else {
                it
            }
        }

        return lines.joinToString(System.lineSeparator()).replace(tocMarker, tocString)

    }


    private fun String.parseHeader(toc: Toc) =
        headerRegex.matchEntire(this)?.let {
            val indent = it.groupValues[1].length
            val title = it.groupValues[2]
            toc.addTocEntry(indent, title)
        }

    private fun String.hasToc(): Boolean =
        this.contains(tocMarker) || this.contains(tocStart)

    private fun MutableListIterator<String>.consumeToc() {
        do {
            this.remove()
        } while (this.hasNext() && this.next() != tocEnd)
        this.set("[TOC]")
    }

    private fun Iterator<String>.consumeCode() {
        while (this.hasNext() && !codeRegex.matches(this.next()));
    }

}
