package ch.derlin.bitdowntoc

data class GeneratorOptions(
    val indentCharacters: List<Char> = listOf('-', '*', '+'),
    val generateAnchors: Boolean = true,
    val trimTocIndent: Boolean = true
)

object BitGenerator {

    data class TocEntry(val indent: Int, val title: String, val link: String)

    // TODO: tests
    private class Toc {
        private val titles: MutableMap<String, Int> = mutableMapOf()
        private val entries: MutableList<TocEntry> = mutableListOf()

        fun addTocEntry(indent: Int, title: String): TocEntry {
            var link = title.escapeTitle()
            // add numbers at the end of the link if it is a duplicate
            val duplicates = (titles.get(title) ?: 0)
            if (duplicates > 0) {
                link += "-${duplicates}"
            }
            titles[title] = duplicates + 1
            // create the entry
            val entry = TocEntry(indent - 1, title, link)
            entries += entry
            return entry
        }

        fun generateToc(indentCharacters: List<Char>, trimTocIndent: Boolean): String {
            val minIndent = if (trimTocIndent) entries.minOf { it.indent } else 0
            return entries.joinToString(System.lineSeparator()) { (indent, text, link) ->
                (indent - minIndent).let {
                    " ".repeat(it * 2) + "${indentCharacters[it % indentCharacters.size]} [$text]($link)"
                }
            }
        }

        private fun String.escapeTitle() =
            this.replace("[^\\w]".toRegex(), "-").toLowerCase()
    }


    private data class State(
        val lines: MutableList<String> = mutableListOf(),
        val toc: Toc = Toc()
    )

    private const val tocMarker = "[TOC]"
    private const val tocStart = "<!-- TOC start -->"
    private const val tocEnd = "<!-- TOC end -->"

    private val headerRegex = "(#+) +([^ ]+.*)".toRegex()
    private val codeRegex = "^```\\w* *$".toRegex()

    private val linkRegex = "<!-- TOC --> <a name=\".*\"></a>.*".toRegex()
    private const val linkFmt = """<!-- TOC --> <a name="%s"></a>"""

    fun generate(text: String, options: GeneratorOptions = GeneratorOptions()): String {

        require(text.hasToc()) {
            "This library requires a [TOC] placeholder (or a TOC previously generated by this library"
        }

        val state = State()
        val iter = text.lineSequence().iterator()

        // consume text up to the toc marker
        while (iter.hasNext() && state.lines.lastOrNull() != tocMarker) {
            val line = iter.next()
            if (line.trim() == tocStart) {
                // a previously generated TOC: remove it and add the toc marker instead
                state.lines += tocMarker
                iter.consumeToc(state)
                break
            } else {
                state.lines += line
            }
        }

        while (iter.hasNext()) {
            val line = iter.next()
            if (codeRegex.matches(line)) {
                state.lines += line
                iter.consumeCode(state)
            } else {
                if (linkRegex.matches(line)) {
                    // do nothing
                } else {
                    state.lines += line
                    line.parseHeader(state)?.let {
                        if (options.generateAnchors)
                            state.lines += listOf(it.genSectionLink() + "")
                    }
                }
            }
        }

        val toc = """
            |$tocStart
            |${state.toc.generateToc(options.indentCharacters, options.trimTocIndent)}
            |$tocEnd
        """.trimMargin() + System.lineSeparator()

        return state.lines.joinToString(System.lineSeparator()).replace(tocMarker, toc)
    }


    private fun String.parseHeader(state: State) =
        headerRegex.matchEntire(this)?.let {
            val indent = it.groupValues[1].length
            val title = it.groupValues[2]
            state.toc.addTocEntry(indent, title)
        }

    private fun String.hasToc(): Boolean =
        this.contains(tocMarker) || this.contains(tocStart)


    private fun TocEntry.genSectionLink() = linkFmt.format(this.link)

    private fun Iterator<String>.consumeToc(state: State) {
        while (this.hasNext() && this.next() != tocEnd);
    }

    private fun Iterator<String>.consumeCode(state: State) {
        while (this.hasNext()) {
            state.lines += this.next()
            if (codeRegex.matches(state.lines.last())) break
        }
    }

}
